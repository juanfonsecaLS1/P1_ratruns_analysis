---
editor: 
  markdown: 
    wrap: 72
---
# Congested Network {#sec-congnet}


```{r,message=FALSE}
#| label: libraries
#| message: false

options(repos = c(CRAN = "https://cloud.r-project.org"))
if (!require("remotes")) install.packages("remotes")
pkgs = c(
    "sf",
    "tidyverse",
    "zonebuilder",
    "tmap"
    # "dodgr" # Using the developer version of dodgr
)
remotes::install_cran(pkgs)
sapply(pkgs, require, character.only = TRUE)

require(dodgr)
packageVersion ("dodgr")
```

## Loading network

```{r}
#| label: read-sf
 
sf_bogota_2019_raw <- st_read(file.path("sf_network","bogota_osm_network.gpkg"),
                              layer = "network_2019") |>
  mutate(way_speed = case_when(highway %in%
                                 c("trunk_link","primary_link","primary","trunk")~"road_60",
                               TRUE ~ "road_30")) |> 
  rename(roadclass = highway) |>
  # mutate(oneway.raw = oneway,
  #        oneway = if_else(roadclass %in% c("residential","unclassified"),
  #                         "no",
  #                         oneway)) |> 
  st_transform(4326)
```

Inspecting the values of the `oneway` tag in residential and unclassified roads

```{r}
sf_bogota_2019_raw |> filter(roadclass %in% c("residential","unclassified")) |> pull(oneway) |> unique()
```

We will reverse those links to allow the vehicles to `travel` in the wrong direction

```{r}
oneway_minor_rev <- sf_bogota_2019_raw |> 
  filter(roadclass %in% c("residential","unclassified"),
         str_detect(pattern = "yes",oneway)) |> 
  st_reverse() |> 
  mutate(osm_id = paste0(osm_id,"r"),
         way_speed = "road_10")
```

```{r}
sf_bogota_2019 <- bind_rows(sf_bogota_2019_raw,
                                 oneway_minor_rev)
```

## Baseline graph building

```{r}
#| label: graph-building
dodgr::clear_dodgr_cache()

graph_bogota <- weight_streetnet(sf_bogota_2019,
                                 left_side = F,
                                 wt_profile_file = "custom_wp_speeds.json",
                                 type_col = "way_speed",
                                 wt_profile = "motorcar",
                                 keep_cols =
                                   c("way_speed","oneway","lanes","surface","maxspeed","roadclass"),
                                 turn_penalty = F)

bog_contracted <- graph_bogota |> 
  dodgr_contract_graph()

```


```{r}
dodgr::clear_dodgr_cache()

bog_contracted$time_weighted <- 3.6*bog_contracted$d_weighted/as.numeric(str_extract(bog_contracted$highway,"\\d{1,2}$"))
```


Calculating the centrality

```{r}
bog_centrality <- bog_contracted |>
      dodgr_centrality(column = "time_weighted",dist_threshold = 900)
```



```{r}
sf_speed <- st_read("sf_network/sf_speed_network.gpkg") |> st_transform(3116)

sf_speed_clean <- sf_speed[sf_bogota_2019 |>
                             st_transform(3116) |>
                             st_union() |>
                             st_convex_hull(),]
```

```{r}
sf_net <- graph_bogota |> 
  dodgr_to_sf() 
```

```{r}
#| label: pre-process-network-2

road_types <- rev(c(
  "trunk"          ,
  "trunk_link"     ,
  "primary"      ,
  "primary_link"   ,
  "secondary"      ,
  "secondary_link" ,
  "tertiary"       ,
  "tertiary_link"  ,
  "unclassified"   ,
  "residential"    
))

sf_bog_major <- sf_net |>
  mutate(roadclass = factor(roadclass,
                          levels = road_types,
                          ordered = T)) |> 
  filter(as.integer(roadclass)>2,str_detect(roadclass,"link",negate = T)) |> 
  st_transform(3116)
```

Extracting bearings and creating a buffer to produce a correspondence
```{r}
#| label: load-speed-data

sf_speed_clean$s.bearing <- stplanr::line_bearing(sf_speed_clean)

speed_buffer <- sf_speed_clean  |>  st_buffer(100,endCapStyle = "FLAT") 
```


```{r}
#| label: spatial-operation-corres

speed_corresp <- st_intersects(speed_buffer,sf_bog_major)

TID_to_edge_id <- do.call(bind_rows,
        lapply(seq_along(speed_corresp),
               \(i) {
                 
                 x <- speed_corresp[[i]]
                 
                 subset_net <- sf_bog_major[x, ]
                 
                 ref_bearing <- speed_buffer$s.bearing[[i]]
                 ref_TID <- speed_buffer$TID[[i]]
                 
                 subset_net$bearing <- stplanr::line_bearing(subset_net)
                 
                 sf_ids <- subset_net |>
                   mutate(bearing_check = round(abs(bearing - ref_bearing))<=15) |>
                   filter(bearing_check) |>
                   pull(edge_id)
                 
                 tibble(TID = ref_TID, edge_id = sf_ids)
                 }
               )
        )
```

It is possible that some links in the road network are found to be linked to multiple links in the 
speed network, so we will resolve such situation. First, we identify the overlaps

```{r}
#| label: pre-process-network
overlap_buffer <- TID_to_edge_id |> 
  unique() |> 
  count(edge_id) |> 
  arrange(-n) |> 
  filter(n>1)
```


```{r}
#| label: check-no-correspondence
no_match_speed <- sf_speed_clean |>
  anti_join(TID_to_edge_id |>
              select(TID) |>
              unique(),
            by = "TID")

nrow(no_match_speed)
```


The following code loads the data

```{r}
#| label: load-speed-summaries

speed_data <- read_csv("sf_network/summary_speeds.csv")
```

We identify the hour that showed the lowest speeds in average

```{r}
#| label: pre-processing-speed

min_speed_key <- speed_data |>
  summarise(mean_norm_speed = mean(d_norm_speed),.by = c(year,day_type,hour)) |> 
  slice_min(mean_norm_speed,by = c(year,day_type)) |> 
  filter(year == 2019,day_type == "weekday") |> 
  select(-mean_norm_speed)
```

We will extract the observed speed for the hour we just identified

```{r}
#| label: subset-chosen-TID

speed_tbl <- speed_data |>
  semi_join(min_speed_key,
            by = join_by(year,day_type,hour)) |> 
  select(TID,d_mean_speed)
```

We join the speed data to the correspondence we produced before

```{r}
#| label: speed-join

obs_speeds_edges <- TID_to_edge_id |>
  left_join(speed_tbl,by = "TID") |> 
  summarise(obs_speed = mean(d_mean_speed),.by = edge_id)
```

Using the observed speed we recalculate the `time_weighted`.

```{r}
#| label: adjust-graph-table

bog_contr_adjusted <- bog_contracted
dodgr::clear_dodgr_cache()
bog_contr_adjusted$obs_speed <- tibble(edge_id = bog_contr_adjusted$edge_id) |> 
  left_join(obs_speeds_edges,by = "edge_id") |> 
  pull(obs_speed)
dodgr::clear_dodgr_cache()
bog_contr_adjusted$time_weighted[!is.na(bog_contr_adjusted$obs_speed)] <- (3.6*bog_contr_adjusted$d_weighted[!is.na(bog_contr_adjusted$obs_speed)])/bog_contr_adjusted$obs_speed[!is.na(bog_contr_adjusted$obs_speed)]
```

We calculate the centrality for the *congested* graph.

```{r}
#| label: centrality-congested
congested_centrality <- bog_contr_adjusted |>
      dodgr_centrality(column = "time_weighted",dist_threshold = 900)
```

#### Comparison

We consolidate the values of free-flow network and congested network into a single dataset

```{r}
#| label: compare-congested-centrality

cent_all <- tibble(edge_id = bog_centrality$edge_id,
                   cent_bl = bog_centrality$centrality) |> 
  left_join(
    tibble(edge_id = congested_centrality$edge_id,
           cent_cong = congested_centrality$centrality),
    by = "edge_id"
  ) |> 
  mutate(
    diff = cent_cong - cent_bl,
    reldiff = diff/(0.5*(cent_bl+cent_cong))
  )
```


```{r}
sf_net_cent <- sf_net |> 
  left_join(cent_all,by = "edge_id")
```

## Saving results for further analysis

```{r}
#| label: save-results

st_write(sf_net_cent,"sf_network/full_sf_network_cent_results.gpkg",delete_dsn = T)
```




