---
editor: 
  markdown: 
    wrap: 72
---

# Joining the WWD reports

```{r,message=FALSE}
#| label: libraries
#| message: false

options(repos = c(CRAN = "https://cloud.r-project.org"))
if (!require("remotes")) install.packages("remotes")
pkgs = c(
    "sf",
    "tidyverse",
    "zonebuilder",
    "tmap"
    # "dodgr" # Using the developer version of dodgr
)
remotes::install_cran(pkgs)
sapply(pkgs, require, character.only = TRUE)
```

## Loading data

```{r}
#| label: zone4clipping

bog_zone <- zonebuilder::zb_zone("Bogota",
                                 n_circles = 3) |> 
  st_transform(4326)
# zb_view(bog_zone)
```

### WWD reports

```{r}
wwd_sf <- st_read("sf_network/wwd_clean_sf.gpkg")
```

### Network

```{r}
sf_net <- st_read("sf_network/small_sf_network_cent_results.gpkg")
```

### Centrality results

```{r}
{
  cent_tests <- read_csv("sf_network/cent_tests.csv",
                         lazy = F)
  cent_tests$logdiff[cent_tests$diff == 0] <- 0
  cent_tests$reldiff[cent_tests$diff==0]<-0
}
```

### Assigning reports to the network

We need to assign the reports to the network. As we are interested in
the residential roads, any bi-directional road is represented in the
`sf` object as two objects. Since we do not have information to know
which specific direction the reports correspond to, we will need to
simplify the spatial object. Our target variable is the betweenness
centrality, so we are going to keep the two centrality values for each
bi-directional element.

First, we will create a subset of the `residential` and `unclassified`
roads

```{r}
subset_net <- sf_net |> 
  filter(roadclass %in% c(
    "residential",
    "unclassified"
    )) |> 
  st_transform(3116)
```

From this subset, we first find the pairs of links with the
`st_contains` function.

```{r}
simplifed_net_indexes <- lapply(st_contains(subset_net,subset_net),
            \(x){
              x[order(x)]
}) |> unique()
```

Each pair is then assigned a unique id.

```{r}
simp_groups <- do.call(bind_rows,
        lapply(seq_along(simplifed_net_indexes),
               \(i){
                 tibble(id = simplifed_net_indexes[[i]],
                        pair_id = i)
               })) |> 
  arrange(id)


subset_net$pair_id <- simp_groups$pair_id
```

Using the `pair_id` we extract the minimum, maximum and average change
in centrality for each pair.

```{r}
summary_pairs <- cent_tests |> 
  right_join(subset_net |>
               st_drop_geometry() |>
               select(edge_id,way_id,pair_id),
            by = "edge_id") |> 
  # Filtering only the links that were inverted during the network creation and standard links
  filter(!any(str_detect(way_id,"r$"))|str_detect(way_id,"r$"),.by = pair_id) |>
  summarise(across(diff:reldiff,
                   list(min=min, max=max, avg = mean)),
            .by = c(pair_id,wwd.speed,dist.th))
```

```{r}
summary_pairs_dist.jct <- 
  subset_net |>
  st_drop_geometry() |>
  filter(!any(str_detect(way_id,"r$"))|str_detect(way_id,"r$"),.by = pair_id) |>
  summarise(across(dist.jct,mean),
            .by = c(pair_id))
```


A simplified version of the `sf` object is produced extracting the first
element of each pair, we will discard columns with the centrality
metrics from this object to avoid confusion

```{r}
# simpl_network_sf <- subset_net[vapply(simplifed_net_indexes,\(x) x[1],numeric(1)),] |> select(lanes:component,pair_id)

simpl_network_sf <- subset_net |>
  # Filtering only the links that were inverted during the network creation and standard links
  filter(!any(str_detect(way_id,"r$"))|str_detect(way_id,"r$"),
         .by = pair_id) |>
  slice_head(n = 1,by = pair_id) |>
  select(lanes:component,pair_id)
```

We are interested in the reports on residential and unclassified
streets. For this, we will create a buffer. It is uncertain how the
coordinates of each report are recorded, there might be some error
associated with the use of GPS devices, and also, some uncertainty in
the way the officers do it.

```{r}
subset_buffer <- simpl_network_sf |> 
  st_union()  |> 
  st_buffer(20)
```

A subset of the reports during peak hour +/- 2 hours

```{r}
subset_wwd <- (wwd_sf |>
                 filter(abs(hour - 18)<=2) |>
                 st_transform(3116))[subset_buffer,]|> 
  filter(year==2019)
```

```{r}
tm_shape(subset_buffer)+
  tm_polygons("gray60",alpha = 0.6)+
  tm_shape(subset_wwd)+
  tm_dots()
```

### Finding the closest element of the network

```{r}
subset_wwd$near_index <- st_nearest_feature(subset_wwd,simpl_network_sf)
subset_wwd$pair_id <- simpl_network_sf$pair_id[subset_wwd$near_index]
```

#### Exploring preliminary results


```{r}
simpl_network_sf |>
  st_drop_geometry() |> 
  filter(pair_id %in% subset_wwd$pair_id) |> 
  ggplot(aes(oneway))+
  geom_bar()
```

```{r}
simpl_network_sf |> 
  ggplot(aes(col = oneway))+
  geom_sf()+
  theme_void()
```

The following plot compares the cumulative probability of distance to
the major network looking for a sampling bias

```{r}
simpl_network_sf |>
  filter(oneway) |> 
  left_join(summary_pairs_dist.jct, by = "pair_id") |> 
  mutate(wwd_bool = pair_id %in% subset_wwd$pair_id) |>
  st_drop_geometry() |> 
  ggplot(aes(dist.jct,col = wwd_bool))+
  stat_ecdf(alpha = 0.7)+
  theme_minimal()
```

The following produces a histogram with the distribution

```{r}
simpl_network_sf |> 
  filter(oneway) |> 
  left_join(summary_pairs_dist.jct, by = "pair_id") |> 
  mutate(wwd_bool = pair_id %in% subset_wwd$pair_id) |>
  st_drop_geometry() |> 
  ggplot(aes(dist.jct, fill = wwd_bool))+
  geom_histogram(alpha = 0.7,col="white")+
  theme_minimal()
```

Let's try see if a naive logistic regression can be fit with the data.
For this, we subset the data for one-way links

```{r}
model_data <- summary_pairs |>
  semi_join(simpl_network_sf |>
              filter(oneway),
            by = "pair_id") |> 
  mutate(wwd_bool = pair_id %in% subset_wwd$pair_id) 
```

A jitter plot to explore the distribution

```{r}
model_data |> 
  filter(wwd.speed == 9, dist.th == 1140) |> 
  ggplot(aes(x = (reldiff_max),y = wwd_bool))+
    geom_jitter(alpha = 0.1)+
  theme_minimal()
```

Distribution of average relative change for the data

```{r}
model_data |> 
    filter(wwd.speed == 9, dist.th == 1140) |> 
  ggplot(aes(x = (reldiff_max),fill = wwd_bool))+
  geom_histogram(alpha = 0.4)+
  theme_minimal()
```

Some OSM links have been split, so we will simplify the data by
summarising the results by OSM way id

```{r}
test1 <- model_data |>
  filter(wwd.speed == 9, dist.th == 1140) |>
  left_join(simpl_network_sf |>
              st_drop_geometry() |> 
              select(pair_id,way_id),
            by = "pair_id") |> 
  group_by(way_id) |> 
  summarise(across(c(diff_max,reldiff_max,logdiff_max),
                   \(x) mean(x,na.rm = T)),
            across(wwd_bool,\(x) sum(x)>=1))

```

The following code shows how a logistic regression fits the data.
Unfortunately, the *false positives* do have a significant impact.

```{r}
test1 |>
  mutate(wwd_bool = if_else(wwd_bool,1,0)) |> 
  ggplot(aes(x = (reldiff_max),y = wwd_bool))+
    geom_point(alpha = 0.1)+
  theme_minimal()+
  geom_smooth(method = "glm",
              formula = y ~ x,
              family = "binomial",
              method.args=list(family="binomial"),se = F)
```


```{r}
test1 |>
  mutate(wwd_bool = if_else(wwd_bool,1,0)) |> 
  ggplot(aes(x = (logdiff_max),
             y = wwd_bool))+
    geom_point(alpha = 0.1)+
  theme_minimal()+
  geom_smooth(method = "glm",
              formula = y ~ x,
              family = "binomial",
              method.args=list(family="binomial"),se = F)
```


```{r}
m1 <- glm(formula = wwd_bool ~ reldiff_max,
          data = test1,
          family = "binomial")

summary(m1)
```

### Filling the reports to adjacent links

```{r}
subset_net_wwd <- subset_net |> 
  # left_join(summary_pairs,
  #           by = "pair_id") |> 
  mutate(wwd_bool = pair_id %in% subset_wwd$pair_id)
```

Let's take one link with a wwd report

```{r}
sample_wwd <- subset_net_wwd |> filter(wwd_bool) |> slice_head(n=1)
```

```{r}
buf_sample <- sample_wwd |> st_buffer(500)
```

```{r}
net_sample <- subset_net_wwd[buf_sample,]

net_sample |> 
  tm_shape()+tm_lines("gray80")+
  tm_shape(sample_wwd)+tm_lines("dodgerblue")
```

```{r}
fill_probs <- function(edges_df,
                       direction = c("1","-1")
                       ) {
  
  direction = match.arg(direction)

    if (direction == "1") {
      do.call(bind_rows, lapply(1:nrow(edges_df), \(j) {
        subset_net_wwd |>
          st_drop_geometry() |>
          select(from_id, to_id) |>
          filter(to_id == edges_df$from_id[j],
                 from_id != edges_df$to_id[j]) |>
          mutate(p = edges_df$p[j] / n())
      }))
  } else {
    do.call(bind_rows, lapply(1:nrow(edges_df), \(j) {
      subset_net_wwd |>
        st_drop_geometry() |>
        select(from_id, to_id) |>
        filter(from_id == edges_df$to_id[j],
               to_id != edges_df$from_id[j]) |>
        mutate(p = edges_df$p[j] / n())
    }))
    
  }
}


expand_reports <- function(
    df,
    max_degree = 6
) {
  
  check0 <- df |>
    st_drop_geometry() |>
    select(from_id, to_id) |>
    mutate(p = 1)
  
  check <- list()
  check[[1]] <- fill_probs(check0)
  for (i in 2:max_degree) {
    if (nrow(check[[i-1]]) < 1) break
    check[[i]] <- fill_probs(check[[i - 1]])
  }
  
  checkr <- list()
  checkr[[1]] <- fill_probs(check0, direction = "-1")
  for (i in 2:max_degree) {
    if (nrow(check[[i - 1]]) < 1) break
    checkr[[i]] <- fill_probs(checkr[[i - 1]], direction = "-1")
  }
  
  ckeck_df <- bind_rows(check0, do.call(bind_rows, check), do.call(bind_rows, checkr)) |>
    summarise(across(p, max), .by = c(from_id, to_id))
  return(ckeck_df)
}

```

```{r}
sample_exp <- expand_reports(sample_wwd)
```

```{r}
net_sample |> 
  left_join(sample_exp,
            by = join_by(from_id,to_id)) |> 
  tm_shape()+
  tm_lines("p",lwd = 2,alpha = 0.5)
```

### Applygin to the whole network

```{r}
full_exp <- subset_net_wwd |> filter(wwd_bool) |> expand_reports()
```

```{r}
full_exp |> nrow()
```

```{r}
full_exp |> select(from_id,to_id) |>  unique() |> nrow()
```

```{r}
summary_probs_adj <- subset_net_wwd |>
  st_drop_geometry() |>
  left_join(full_exp,
            by = join_by(from_id, to_id)) |>
  mutate(p = if_else(is.na(p),0,p)) |> 
  # Filtering only the links that were inverted during the network creation and standard links
  # filter(!any(str_detect(way_id,"r$"))|str_detect(way_id,"r$"),.by = pair_id) |> 
  summarise(across(p,\(x) sum(x,na.rm = T)),
            .by = pair_id) |>
  mutate(p = if_else(p>1,1,p))
  
```

```{r}
net_wwd_p <- simpl_network_sf |>
  left_join(summary_probs_adj,
            by = "pair_id")
```

```{r}
tm_shape(net_wwd_p)+
  tm_lines("p",style = "fisher")
```




```{r}
adjusted_probs_model_data <- summary_pairs |> 
  left_join(net_wwd_p |> 
              st_drop_geometry(),
            by = join_by(pair_id))
```

```{r}
glm_models <- adjusted_probs_model_data |> 
  nest(data = c(pair_id,diff_min:p)) |> 
  mutate(
    model_rel = map(data,
                \(.x) {
                 glm(p ~ reldiff_max,
                     data = .x,
                     family = binomial(link = "logit"))
                },
                model_abs = map(data,
                \(.x) {
                 glm(p ~ logdiff_max,
                     data = .x,
                     family = binomial(link = "logit"))
                }
                )
                )
    )

```


